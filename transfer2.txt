creates vertical box plots that dynamically updates values
import matplotlib.pyplot as plt

# Custom values for the boxplots
array1 = [1, 2, 3, 4, 5]
array2 = [2, 3, 4, 5, 7]
array3 = [3, 4, 5, 6, 8]

# Creating the figure and axis
fig, ax = plt.subplots()

# Creating the boxplots
boxplot = ax.boxplot([array1, array2, array3], vert=True, widths=0.5, patch_artist=True)

# Customizing the boxplot colors
colors = ['lightblue', 'lightblue', 'lightblue']
for patch, color in zip(boxplot['boxes'], colors):
    patch.set_facecolor(color)

for i, box in enumerate(boxplot['boxes']):
    # Get the vertices (coordinates) of the box
    box_coords = box.get_path().vertices
    
    # Calculate the x-coordinate of the middle of the box
    mid_x = (box_coords[0, 0] + box_coords[2, 0]) / 2
    
    # Calculate the statistics for the current box plot
    box_values = boxplot['medians'][i].get_ydata()
    box_min = boxplot['caps'][2*i].get_ydata()[0]
    box_max = boxplot['caps'][2*i + 1].get_ydata()[0]
    
    # Add value label for the top line
    ax.text(mid_x + 0.3, box_max, f'{box_max:.1f}', color='black', fontsize=8, verticalalignment='center')
    
    # Add value label for the bottom line
    ax.text(mid_x + 0.3, box_min, f'{box_min:.1f}', color='black', fontsize=8, verticalalignment='center')

    # Add value label for the middle line
    ax.text(mid_x + 0.3, box_values[0], f'{box_values[0]:.1f}', color='black', fontsize=8, verticalalignment='center')

# Setting the y-axis limits and ticks
ax.set_ylim(-5, 10)
ax.set_yticks([i / 10 for i in range(-50, 110, 10)])
ax.set_yticklabels([str(i / 10) for i in range(-50, 110, 10)])

# Setting the x-axis label
ax.set_xlabel('Box Plots')

# Adding a title
ax.set_title('Custom Vertical Box Plots with Value Labels for Top, Bottom, and Middle Lines')

# Displaying the plot
plt.show()

-----------------------------------------------------------
only graphs when array has values, if array = ["","","","",""] then it will not create a box plot
import matplotlib.pyplot as plt
import numpy as np

# Custom values for the boxplots
array1 = [1, 2, 3, 4, 5]
array2 = [3,4,5,6,7]
array3 = [8,9,10,11,12]

# Creating the figure and axis
fig, ax = plt.subplots()

# Creating the boxplots
data = []

if array1 and not any(val != "" for val in array2) and not any(val != "" for val in array3):
    # Only array1 has values, arrays 2 and 3 are all empty
    data.append(array1)

elif array1 and array2 and not any(val != "" for val in array3):
    # Array1 and array2 have values, array3 is all empty
    data.append(array1)
    data.append(array2)

elif array1 and array2 and array3:
    # All arrays have values
    data.append(array1)
    data.append(array2)
    data.append(array3)

if data:
    boxplot = ax.boxplot(data, vert=True, widths=0.5, patch_artist=True)

    # Customizing the boxplot colors
    colors = ['lightblue'] * len(data)
    for patch, color in zip(boxplot['boxes'], colors):
        patch.set_facecolor(color)

    for i, box in enumerate(boxplot['boxes']):
        if i < len(data):
            # Get the vertices (coordinates) of the box
            box_coords = box.get_path().vertices

            # Calculate the x-coordinate of the middle of the box
            mid_x = (box_coords[0, 0] + box_coords[2, 0]) / 2

            # Calculate the statistics for the current box plot
            box_values = boxplot['medians'][i].get_ydata()
            box_min = boxplot['caps'][2 * i].get_ydata()[0]
            box_max = boxplot['caps'][2 * i + 1].get_ydata()[0]

            # Add value label for the top line
            ax.text(mid_x + 0.3, box_max, f'{box_max:.1f}', color='black', fontsize=8, verticalalignment='center')

            # Add value label for the bottom line
            ax.text(mid_x + 0.3, box_min, f'{box_min:.1f}', color='black', fontsize=8, verticalalignment='center')

            # Add value label for the middle line
            ax.text(mid_x + 0.3, box_values[0], f'{box_values[0]:.1f}', color='black', fontsize=8, verticalalignment='center')

# Setting the y-axis limits and ticks
min_value = np.inf if not data else np.nanmin([np.nanmin(arr) for arr in data])
max_value = -np.inf if not data else np.nanmax([np.nanmax(arr) for arr in data])
ax.set_ylim(min_value, max_value)
ax.set_yticks(np.linspace(min_value, max_value, num=6))

# Setting the x-axis label
ax.set_xlabel('Box Plots')

# Adding a title
ax.set_title('Custom Vertical Box Plots with Value Labels')

# Displaying the plot
plt.show()

---------------------------------------------------------------
code to create secondary axis for outlier data - BROKEN
import matplotlib.pyplot as plt
import numpy as np

# Custom values for the box plots
array1 = [1, 2, 3, 4, 5]
array2 = [45, 47, 48, 50, 58]
array3 = [1, 2, 3, 4, 5]

# Creating the figure and primary axis
fig, ax = plt.subplots()

# Creating the boxplots
data = []

if array1 and not any(val != "" for val in array2) and not any(val != "" for val in array3):
    # Only array1 has values, arrays 2 and 3 are all empty
    data.append(array1)

elif array1 and array2 and not any(val != "" for val in array3):
    # Array1 and array2 have values, array3 is all empty
    data.append(array1)
    data.append(array2)

elif array1 and array2 and array3:
    # All arrays have values
    data.append(array1)
    data.append(array2)
    data.append(array3)

if data:
    boxplot = ax.boxplot(data, vert=True, widths=0.5, patch_artist=True)

    # Customizing the boxplot colors
    colors = ['lightblue'] * len(data)
    for patch, color in zip(boxplot['boxes'], colors):
        patch.set_facecolor(color)

    for i, box in enumerate(boxplot['boxes']):
        if i < len(data):
            # Get the vertices (coordinates) of the box
            box_coords = box.get_path().vertices

            # Calculate the x-coordinate of the middle of the box
            mid_x = (box_coords[0, 0] + box_coords[2, 0]) / 2

            # Calculate the statistics for the current box plot
            box_values = boxplot['medians'][i].get_ydata()
            box_min = boxplot['caps'][2 * i].get_ydata()[0]
            box_max = boxplot['caps'][2 * i + 1].get_ydata()[0]

            # Add value label for the top line
            ax.text(mid_x + 0.3, box_max, f'{box_max:.1f}', color='black', fontsize=8, verticalalignment='center')

            # Add value label for the bottom line
            ax.text(mid_x + 0.3, box_min, f'{box_min:.1f}', color='black', fontsize=8, verticalalignment='center')

            # Add value label for the middle line
            ax.text(mid_x + 0.3, box_values[0], f'{box_values[0]:.1f}', color='black', fontsize=8, verticalalignment='center')

    # Check if a secondary y-axis is needed
    if len(data) > 1:
        # Find the array with smaller values (array1 or array3) and assign it to the primary y-axis
        primary_data = array1 if np.nanmax(array1) < np.nanmax(array3) else array3

        # Create the secondary y-axis for array2 with larger values
        ax_sec = ax.twinx()

        # Plot array2 on the secondary y-axis
        ax_sec.plot([], [])  # Dummy plot for the secondary y-axis to avoid overlapping with the primary y-axis

        # Calculate the min and max values for the primary y-axis limits
        primary_min_value = np.nanmin(primary_data)
        primary_max_value = np.nanmax(primary_data)

        # Setting the primary y-axis limits and ticks
        ax.set_ylim(primary_min_value, primary_max_value)
        ax.set_yticks(np.linspace(primary_min_value, primary_max_value, num=6))

        # Calculate the min and max values for the secondary y-axis limits
        secondary_min_value = np.nanmin(array2)
        secondary_max_value = np.nanmax(array2)

        # Setting the secondary y-axis limits and ticks
        ax_sec.set_ylim(secondary_min_value, secondary_max_value)
        ax_sec.set_yticks(np.linspace(secondary_min_value, secondary_max_value, num=6))

        # Set the label for the secondary y-axis
        ax_sec.set_ylabel('Secondary Y-axis')

# Setting the x-axis label
ax.set_xlabel('Box Plots')

# Adding a title
ax.set_title('Custom Vertical Box Plots with Value Labels')

# Displaying the plot
plt.show()

----------------------------
just secondary y

import matplotlib.pyplot as plt
import numpy as np

# Custom values for the box plots
array1 = [1, 2, 3, 4, 5]
array2 = [45, 47, 48, 50, 58]

# Creating the figure and primary axis
fig, ax = plt.subplots()

# Creating the boxplots
data = [array1, array2]

boxplot = ax.boxplot(data, vert=True, widths=0.5, patch_artist=True)

# Create a secondary y-axis for the box plot with larger values
ax_sec = ax.twinx()

# Customize the appearance of the secondary y-axis
ax_sec.spines['right'].set_visible(True)
ax_sec.yaxis.set_label_position('right')
ax_sec.yaxis.set_ticks_position('right')

# Set the label for the secondary y-axis
ax_sec.set_ylabel('Secondary Y-axis')

# Displaying the plot
plt.show()

-------

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats

# Load the data from Excel
data = pd.read_excel('path_to_your_excel_file.xlsx', sheet_name='sheet_name', skiprows=4)

# Extract the relevant data from column C (assuming it's the third column)
column_index = 2  # Replace with the actual column index (zero-based)
relevant_data = data.iloc[:, column_index]

# Remove missing or infinite values
relevant_data = relevant_data.replace([np.inf, -np.inf], np.nan).dropna()

# Plot a histogram of the data
sns.histplot(data=relevant_data, kde=True)
plt.xlabel('Values')
plt.ylabel('Frequency')
plt.title('Histogram of Data')
plt.show()

# Fit different distribution models and find the best fit
distributions = [
    'norm',  # Normal distribution
    'expon',  # Exponential distribution
    'gamma',  # Gamma distribution
    'lognorm',  # Log-normal distribution
]

best_fit = None
best_fit_params = {}
best_fit_name = ''
best_fit_aic = float('inf')

for distribution in distributions:
    # Fit the distribution to the data
    params = getattr(stats, distribution).fit(relevant_data)
    
    # Calculate the log-likelihood
    log_likelihood = np.sum(getattr(stats, distribution).logpdf(relevant_data, *params))
    
    # Calculate the AIC (Akaike Information Criterion)
    k = len(params)
    n = len(relevant_data)
    aic = -2 * log_likelihood + 2 * k
    
    # Check if this distribution has a better fit
    if aic < best_fit_aic:
        best_fit = getattr(stats, distribution)
        best_fit_params = params
        best_fit_name = distribution
        best_fit_aic = aic

# Plot the best-fit distribution over the histogram
sns.histplot(data=relevant_data, kde=True)
x = pd.Series(best_fit.rvs(size=len(relevant_data), *best_fit_params))
sns.histplot(x, kde=True, color='r', label=best_fit_name)

plt.xlabel('Values')
plt.ylabel('Frequency')
plt.title('Histogram with Best-Fit Distribution')
plt.legend()
plt.show()


import numpy as np
from scipy.stats import norm, gamma, expon, lognorm

# Parameters for the distributions
normal_mean = 5
normal_std = 2
gamma_shape = 2
gamma_scale = 3
expon_rate = 0.5
lognorm_mean = 2
lognorm_std = 0.5

# Values for which probabilities are calculated
values = [10, 15, 8, 12]

# Calculate probabilities for each distribution
normal_probabilities = norm.pdf(values, loc=normal_mean, scale=normal_std)
gamma_probabilities = gamma.pdf(values, gamma_shape, loc=0, scale=gamma_scale)
expon_probabilities = expon.pdf(values, loc=0, scale=1/expon_rate)
lognorm_probabilities = lognorm.pdf(values, lognorm_std, loc=0, scale=np.exp(lognorm_mean))

# Print the calculated probabilities
print("Normal Distribution Probabilities:")
for val, prob in zip(values, normal_probabilities):
    print(f"Value: {val}, Probability: {prob}")

print("\nGamma Distribution Probabilities:")
for val, prob in zip(values, gamma_probabilities):
    print(f"Value: {val}, Probability: {prob}")

print("\nExponential Distribution Probabilities:")
for val, prob in zip(values, expon_probabilities):
    print(f"Value: {val}, Probability: {prob}")

print("\nLog-Normal Distribution Probabilities:")
for val, prob in zip(values, lognorm_probabilities):
    print(f"Value: {val}, Probability: {prob}")


