this is my code. i want the y axis to automatically add more ticks if user zooms in on the graph

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import matplotlib.patches as mpatches
import tkinter as tk
from tkinter import ttk

def charts():
    file = pd.ExcelFile("volpath.1.xlsm")

    df = file.parse('Func_hide', header = None , skiprows=1, usecols="M:T", nrows = 3)
    df2 = file.parse('Func_hide', header= None, skiprows=1, usecols="U:V", nrows = 3)
    
    roll1 = df2.iloc[0,:].tolist()
    roll2 = df2.iloc[1,:].tolist()
    roll3 = df2.iloc[2,:].tolist()

    print(roll2)
    global array1, array2, array3
    array1 = df.iloc[0,3:].tolist()
    array2 = df.iloc[1,3:].tolist()
    array3 = df.iloc[2,3:].tolist()
    combinedArr = array1 + array2 + array3
    

    global chart1, chart2, chart3
    chart1 = str(df.iloc[0,1]) + " " +str(df.iloc[0,2])
    chart2 = str(df.iloc[1,1]) + " " +str(df.iloc[1,2])
    chart3 = str(df.iloc[2,1]) + " " +str(df.iloc[2,2])

    # Custom values for the boxplots
    # array1 = [-0.5, -.45, 0.12, .24, .5]
    # array2 = [1.7,4,5,5.9,7]
    # array3 = [22,24,25,26,28]
    # combinedArr = array1 + array2 + array3
    # chart1, chart2, chart3 = "chart", "chart", "chart"

    plt.ion()

    # Creating the figure and axis
    fig, ax = plt.subplots()
    fig.set_size_inches(10,8)

   
    # Creating the boxplots
    data = []

    if array1 and not any(val != "" for val in array2) and not any(val != "" for val in array3):
        # Only array1 has values, arrays 2 and 3 are all empty
        data.append(array1)

    elif array1 and array2 and not any(val != "" for val in array3):
        # Array1 and array2 have values, array3 is all empty
        data.append(array1)
        data.append(array2)

    elif array1 and array2 and array3:
        # All arrays have values
        data.append(array1)
        data.append(array2)
        data.append(array3)

    if data:
        boxplot = ax.boxplot(data, vert=True, widths=0.5, patch_artist=True)

        # Customizing the boxplot colors
        colors = ['lightblue'] * len(data)
        for patch, color in zip(boxplot['boxes'], colors):
            patch.set_facecolor(color)

        for i, box in enumerate(boxplot['boxes']):
            if i < len(data):
                # Get the vertices (coordinates) of the box
                box_coords = box.get_path().vertices

                # Calculate the x-coordinate of the middle of the box
                mid_x = (box_coords[0, 0] + box_coords[2, 0]) / 2

                # Calculate the statistics for the current box plot
                box_values = boxplot['medians'][i].get_ydata()
                box_min = boxplot['caps'][2 * i].get_ydata()[0]
                box_max = boxplot['caps'][2 * i + 1].get_ydata()[0]

                # Add value labels for the 30d Low/High
                quartile_values = np.percentile(data[i], [25,75])

                # if not box_min / quartile_values[0] > 0.95 or not  box_values[0] / quartile_values[0]  > 0.95:
                #     ax.text(mid_x + 0.3, quartile_values[0], f'30d Low {quartile_values[0]:.3f}', color='blue', fontsize=6, verticalalignment='center')
                # elif box_min / quartile_values[0] > 0.95:
                #     ax.text(mid_x + 0.55, quartile_values[0], f'30d Low {quartile_values[0]:.3f}', color='blue', fontsize=6, verticalalignment='center')
                # elif quartile_values[0] / box_values[0] > 0.95:
                #     ax.text(mid_x + 0.55, quartile_values[0], f'30d Low {quartile_values[0]:.3f}', color='blue', fontsize=6, verticalalignment='center')

                ax.text(mid_x + 0.5, quartile_values[0], f'30d Low {quartile_values[0]:.3f}', color='blue', fontsize=6, verticalalignment='center')
                
                # if not quartile_values[1] / box_max > 0.95 or not box_values[0] / quartile_values[1] > 0.95:
                #     ax.text(mid_x + 0.3, quartile_values[1], f'30d High {quartile_values[1]:.3f}', color='blue', fontsize=6, verticalalignment='center')
                # elif quartile_values[1] / box_max > 0.95:
                #     ax.text(mid_x + 0.55, quartile_values[1], f'30d High {quartile_values[1]:.3f}', color='blue', fontsize=6, verticalalignment='center')
                # elif box_values[0] / quartile_values[1] > 0.95:
                #     ax.text(mid_x + 0.55, quartile_values[1], f'30d High {quartile_values[1]:.3f}', color='blue', fontsize=6, verticalalignment='center')

                ax.text(mid_x + 0.5, quartile_values[1], f'30d Low {quartile_values[1]:.3f}', color='blue', fontsize=6, verticalalignment='center')

                # Add value label for the 60d High
                ax.text(mid_x + 0.3, box_max, f'60d High {box_max:.3f}', color='green', fontsize=6, verticalalignment='center')

                # Add value label for the 60d Low
                ax.text(mid_x + 0.3, box_min, f'60d Low {box_min:.3f}', color='green', fontsize=6, verticalalignment='center')

                # Add value label for the Current Vol
                ax.text(mid_x + 0.3, box_values[0], f'Curr. Vol {box_values[0]:.3f}', color='red', fontsize=6, verticalalignment='center')
    # Adding legend
    green = mpatches.Patch(color= 'green', label = '60 Day')
    red = mpatches.Patch(color='red', label = "Curr. Vol")
    blue = mpatches.Patch(color='blue', label = "30 Day")
    plt.legend(handles=[green,red,blue])

    # Setting the y-axis limits and ticks
    min_value = np.inf if not data else np.nanmin([np.nanmin(arr) for arr in data])
    max_value = -np.inf if not data else np.nanmax([np.nanmax(arr) for arr in data])
    ax.set_ylim(min_value * .5, max_value * 1.5 )
    ax.set_yticks(np.linspace(min_value - 1, max_value + 1, num=10))



    # Setting the x-axis label
    ax.set_xlabel(chart1 + " / " + chart2 + " / " + chart3)

    # Adding a title
    ax.set_title('Volpath')

    
    root = tk.Tk()
    root.title("Volpath")

    table = ttk.Treeview(root)
    table["columns"] = ("array1", "array2", "array3")
    table.column("#0", width=100, minwidth=50)
    table.column("array1", width=100, minwidth=100)
    table.column("array2", width=100, minwidth=100)
    table.column("array3", width=100, minwidth=100)

    table.heading("#0", text="Contract")
    table.heading("array1", text=chart1)
    table.heading("array2", text=chart2)
    table.heading("array3", text=chart3)
    
    if not any(val != "" for val in array3):
        array3= ["","","","",""]
    if not any(val != "" for val in array2):
        array2 = ["","","","",""]


    index = ""
    for i in range(len(array1) + 2):
        if i == 0:
            index = "60d Low"
        if i == 1:
            index = "30d Low"
        if i == 2:
            index = "Curr. Vol"
        if i == 3:
            index = "30d High"
        if i == 4:
            index = "60d High"
        if i == 5:
            index = "10d Rolling"
        if i == 6:
            index = "30d Rolling"
        if i <= 4:
            table.insert("", "end", text=index, values=(round(array1[i],3), round(array2[i],3), round((array3[i]),3)))
        else:
          table.insert("", "end", text=index, values=(round(roll1[i-5],3), round(roll2[i-5],3), round((roll3[i-5]),3)))

    table.pack(padx=10, pady=10)
    
    plt.show()
    root.mainloop()

charts()

