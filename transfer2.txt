
Sub CreateStackedColumnChart()
    Dim ws As Worksheet
    Dim cht As ChartObject
    Dim rngData As Range
    Dim chtTitle As String
    
    ' Set the worksheet
    Set ws = ThisWorkbook.Sheets("Sheet1") ' Replace "Sheet1" with your actual sheet name
    
    ' Set the range for the chart data
    Set rngData = ws.Range("E3:K7")
    
    ' Set the chart title
    chtTitle = ws.Range("E1").Value
    
    ' Add a new chart object to the worksheet
    Set cht = ws.ChartObjects.Add(Left:=100, Width:=400, Top:=100, Height:=300)
    
    ' Set the chart type to stacked column
    cht.Chart.ChartType = xlColumnStacked
    
    ' Set the chart data source
    cht.Chart.SetSourceData rngData
    
    ' Add data labels to the chart
    cht.Chart.ApplyDataLabels Type:=xlDataLabelsShowValue
    
    ' Set the x-axis to display at the bottom
    cht.Chart.Axes(xlCategory).HasTitle = True
    cht.Chart.Axes(xlCategory).AxisTitle.Text = ""
    cht.Chart.Axes(xlCategory).TickLabels.Position = xlTickLabelPositionLow
    
    ' Rename the y-axis
    cht.Chart.Axes(xlValue).HasTitle = True
    cht.Chart.Axes(xlValue).AxisTitle.Text = "Price"
    
    ' Hide the grid lines
    cht.Chart.Axes(xlValue).HasMajorGridlines = False
    cht.Chart.Axes(xlValue).HasMinorGridlines = False
    
    ' Link the chart title to cell E1
    cht.Chart.HasTitle = True
    cht.Chart.ChartTitle.Text = "=" & ws.Name & "!" & ws.Range("E1").Address
    
End Sub







this is my code. i want the y axis to automatically add more ticks if user zooms in on the graph

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import matplotlib.patches as mpatches
import tkinter as tk
from tkinter import ttk

def charts():
    file = pd.ExcelFile("volpath.1.xlsm")

    df = file.parse('Func_hide', header = None , skiprows=1, usecols="M:T", nrows = 3)
    df2 = file.parse('Func_hide', header= None, skiprows=1, usecols="U:V", nrows = 3)
    
    roll1 = df2.iloc[0,:].tolist()
    roll2 = df2.iloc[1,:].tolist()
    roll3 = df2.iloc[2,:].tolist()

    print(roll2)
    global array1, array2, array3
    array1 = df.iloc[0,3:].tolist()
    array2 = df.iloc[1,3:].tolist()
    array3 = df.iloc[2,3:].tolist()
    combinedArr = array1 + array2 + array3
    

    global chart1, chart2, chart3
    chart1 = str(df.iloc[0,1]) + " " +str(df.iloc[0,2])
    chart2 = str(df.iloc[1,1]) + " " +str(df.iloc[1,2])
    chart3 = str(df.iloc[2,1]) + " " +str(df.iloc[2,2])

    # Custom values for the boxplots
    # array1 = [-0.5, -.45, 0.12, .24, .5]
    # array2 = [1.7,4,5,5.9,7]
    # array3 = [22,24,25,26,28]
    # combinedArr = array1 + array2 + array3
    # chart1, chart2, chart3 = "chart", "chart", "chart"

    plt.ion()

    # Creating the figure and axis
    fig, ax = plt.subplots()
    fig.set_size_inches(10,8)

   
    # Creating the boxplots
    data = []

    if array1 and not any(val != "" for val in array2) and not any(val != "" for val in array3):
        # Only array1 has values, arrays 2 and 3 are all empty
        data.append(array1)

    elif array1 and array2 and not any(val != "" for val in array3):
        # Array1 and array2 have values, array3 is all empty
        data.append(array1)
        data.append(array2)

    elif array1 and array2 and array3:
        # All arrays have values
        data.append(array1)
        data.append(array2)
        data.append(array3)

    if data:
        boxplot = ax.boxplot(data, vert=True, widths=0.5, patch_artist=True)

        # Customizing the boxplot colors
        colors = ['lightblue'] * len(data)
        for patch, color in zip(boxplot['boxes'], colors):
            patch.set_facecolor(color)

        for i, box in enumerate(boxplot['boxes']):
            if i < len(data):
                # Get the vertices (coordinates) of the box
                box_coords = box.get_path().vertices

                # Calculate the x-coordinate of the middle of the box
                mid_x = (box_coords[0, 0] + box_coords[2, 0]) / 2

                # Calculate the statistics for the current box plot
                box_values = boxplot['medians'][i].get_ydata()
                box_min = boxplot['caps'][2 * i].get_ydata()[0]
                box_max = boxplot['caps'][2 * i + 1].get_ydata()[0]

                # Add value labels for the 30d Low/High
                quartile_values = np.percentile(data[i], [25,75])

                # if not box_min / quartile_values[0] > 0.95 or not  box_values[0] / quartile_values[0]  > 0.95:
                #     ax.text(mid_x + 0.3, quartile_values[0], f'30d Low {quartile_values[0]:.3f}', color='blue', fontsize=6, verticalalignment='center')
                # elif box_min / quartile_values[0] > 0.95:
                #     ax.text(mid_x + 0.55, quartile_values[0], f'30d Low {quartile_values[0]:.3f}', color='blue', fontsize=6, verticalalignment='center')
                # elif quartile_values[0] / box_values[0] > 0.95:
                #     ax.text(mid_x + 0.55, quartile_values[0], f'30d Low {quartile_values[0]:.3f}', color='blue', fontsize=6, verticalalignment='center')

                ax.text(mid_x + 0.5, quartile_values[0], f'30d Low {quartile_values[0]:.3f}', color='blue', fontsize=6, verticalalignment='center')
                
                # if not quartile_values[1] / box_max > 0.95 or not box_values[0] / quartile_values[1] > 0.95:
                #     ax.text(mid_x + 0.3, quartile_values[1], f'30d High {quartile_values[1]:.3f}', color='blue', fontsize=6, verticalalignment='center')
                # elif quartile_values[1] / box_max > 0.95:
                #     ax.text(mid_x + 0.55, quartile_values[1], f'30d High {quartile_values[1]:.3f}', color='blue', fontsize=6, verticalalignment='center')
                # elif box_values[0] / quartile_values[1] > 0.95:
                #     ax.text(mid_x + 0.55, quartile_values[1], f'30d High {quartile_values[1]:.3f}', color='blue', fontsize=6, verticalalignment='center')

                ax.text(mid_x + 0.5, quartile_values[1], f'30d Low {quartile_values[1]:.3f}', color='blue', fontsize=6, verticalalignment='center')

                # Add value label for the 60d High
                ax.text(mid_x + 0.3, box_max, f'60d High {box_max:.3f}', color='green', fontsize=6, verticalalignment='center')

                # Add value label for the 60d Low
                ax.text(mid_x + 0.3, box_min, f'60d Low {box_min:.3f}', color='green', fontsize=6, verticalalignment='center')

                # Add value label for the Current Vol
                ax.text(mid_x + 0.3, box_values[0], f'Curr. Vol {box_values[0]:.3f}', color='red', fontsize=6, verticalalignment='center')
    # Adding legend
    green = mpatches.Patch(color= 'green', label = '60 Day')
    red = mpatches.Patch(color='red', label = "Curr. Vol")
    blue = mpatches.Patch(color='blue', label = "30 Day")
    plt.legend(handles=[green,red,blue])

    # Setting the y-axis limits and ticks
    min_value = np.inf if not data else np.nanmin([np.nanmin(arr) for arr in data])
    max_value = -np.inf if not data else np.nanmax([np.nanmax(arr) for arr in data])
    ax.set_ylim(min_value * .5, max_value * 1.5 )
    ax.set_yticks(np.linspace(min_value - 1, max_value + 1, num=10))



    # Setting the x-axis label
    ax.set_xlabel(chart1 + " / " + chart2 + " / " + chart3)

    # Adding a title
    ax.set_title('Volpath')

    
    root = tk.Tk()
    root.title("Volpath")

    table = ttk.Treeview(root)
    table["columns"] = ("array1", "array2", "array3")
    table.column("#0", width=100, minwidth=50)
    table.column("array1", width=100, minwidth=100)
    table.column("array2", width=100, minwidth=100)
    table.column("array3", width=100, minwidth=100)

    table.heading("#0", text="Contract")
    table.heading("array1", text=chart1)
    table.heading("array2", text=chart2)
    table.heading("array3", text=chart3)
    
    if not any(val != "" for val in array3):
        array3= ["","","","",""]
    if not any(val != "" for val in array2):
        array2 = ["","","","",""]


    index = ""
    for i in range(len(array1) + 2):
        if i == 0:
            index = "60d Low"
        if i == 1:
            index = "30d Low"
        if i == 2:
            index = "Curr. Vol"
        if i == 3:
            index = "30d High"
        if i == 4:
            index = "60d High"
        if i == 5:
            index = "10d Rolling"
        if i == 6:
            index = "30d Rolling"
        if i <= 4:
            table.insert("", "end", text=index, values=(round(array1[i],3), round(array2[i],3), round((array3[i]),3)))
        else:
          table.insert("", "end", text=index, values=(round(roll1[i-5],3), round(roll2[i-5],3), round((roll3[i-5]),3)))

    table.pack(padx=10, pady=10)
    
    plt.show()
    root.mainloop()

charts()

---

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import matplotlib.patches as mpatches
import tkinter as tk
from tkinter import ttk

def charts():
    file = pd.ExcelFile("volpath.1.xlsm")

    df = file.parse('Func_hide', header=None, skiprows=1, usecols="M:T", nrows=3)
    df2 = file.parse('Func_hide', header=None, skiprows=1, usecols="U:V", nrows=3)

    roll1 = df2.iloc[0, :].tolist()
    roll2 = df2.iloc[1, :].tolist()
    roll3 = df2.iloc[2, :].tolist()

    print(roll2)
    global array1, array2, array3
    array1 = df.iloc[0, 3:].tolist()
    array2 = df.iloc[1, 3:].tolist()
    array3 = df.iloc[2, 3:].tolist()
    combinedArr = array1 + array2 + array3

    global chart1, chart2, chart3
    chart1 = str(df.iloc[0, 1]) + " " + str(df.iloc[0, 2])
    chart2 = str(df.iloc[1, 1]) + " " + str(df.iloc[1, 2])
    chart3 = str(df.iloc[2, 1]) + " " + str(df.iloc[2, 2])

    plt.ion()

    # Creating the figure and axis
    fig, ax = plt.subplots()
    fig.set_size_inches(10, 8)

    # Creating the boxplots
    data = []

    if array1 and not any(val != "" for val in array2) and not any(val != "" for val in array3):
        # Only array1 has values, arrays 2 and 3 are all empty
        data.append(array1)

    elif array1 and array2 and not any(val != "" for val in array3):
        # Array1 and array2 have values, array3 is all empty
        data.append(array1)
        data.append(array2)

    elif array1 and array2 and array3:
        # All arrays have values
        data.append(array1)
        data.append(array2)
        data.append(array3)

    if data:
        boxplot = ax.boxplot(data, vert=True, widths=0.5, patch_artist=True)

        # Customizing the boxplot colors
        colors = ['lightblue'] * len(data)
        for patch, color in zip(boxplot['boxes'], colors):
            patch.set_facecolor(color)

        for i, box in enumerate(boxplot['boxes']):
            if i < len(data):
                # Get the vertices (coordinates) of the box
                box_coords = box.get_path().vertices

                # Calculate the x-coordinate of the middle of the box
                mid_x = (box_coords[0, 0] + box_coords[2, 0]) / 2

                # Calculate the statistics for the current box plot
                box_values = boxplot['medians'][i].get_ydata()
                box_min = boxplot['caps'][2 * i].get_ydata()[0]
                box_max = boxplot['caps'][2 * i + 1].get_ydata()[0]

                # Add value labels for the 30d Low/High
                quartile_values = np.percentile(data[i], [25, 75])

                ax.text(mid_x + 0.5, quartile_values[0], f'30d Low {quartile_values[0]:.3f}', color='blue',
                        fontsize=6, verticalalignment='center')

                ax.text(mid_x + 0.5, quartile_values[1], f'30d Low {quartile_values[1]:.3f}', color='blue',
                        fontsize=6, verticalalignment='center')

                # Add value label for the 60d High
                ax.text(mid_x + 0.3, box_max, f'60d High {box_max:.3f}', color='green', fontsize=6,
                        verticalalignment='center')

                # Add value label for the 60d Low
                ax.text(mid_x + 0.3, box_min, f'60d Low {box_min:.3f}', color='green', fontsize=6,
                        verticalalignment='center')

                # Add value label for the Current Vol
                ax.text(mid_x + 0.3, box_values[0], f'Curr. Vol {box_values[0]:.3f}', color='red', fontsize=6,
                        verticalalignment='center')

    # Adding legend
    green = mpatches.Patch(color='green', label='60 Day')
    red = mpatches.Patch(color='red', label="Curr. Vol")
    blue = mpatches.Patch(color='blue', label="30 Day")
    plt.legend(handles=[green, red, blue])

    # Setting the y-axis limits and ticks
    min_value = np.inf if not data else np.nanmin([np.nanmin(arr) for arr in data])
    max_value = -np.inf if not data else np.nanmax([np.nanmax(arr) for arr in data])
    ax.set_ylim(min_value * .5, max_value * 1.5)

    def update_ticks(event_ax):
        # Update the number of ticks on the y-axis based on the zoom level
        zoom_level = event_ax.get_zoom()
        num_ticks = 10 if zoom_level == 1.0 else int(zoom_level * 10)
        ax.locator_params(axis='y', nbins=num_ticks)

    ax.callbacks.connect('ylim_changed', update_ticks)

    # Setting the x-axis label
    ax.set_xlabel(chart1 + " / " + chart2 + " / " + chart3)

    # Adding a title
    ax.set_title('Volpath')

    root = tk.Tk()
    root.title("Volpath")

    table = ttk.Treeview(root)
    table["columns"] = ("array1", "array2", "array3")
    table.column("#0", width=100, minwidth=50)
    table.column("array1", width=100, minwidth=100)
    table.column("array2", width=100, minwidth=100)
    table.column("array3", width=100, minwidth=100)

    table.heading("#0", text="Contract")
    table.heading("array1", text=chart1)
    table.heading("array2", text=chart2)
    table.heading("array3", text=chart3)

    if not any(val != "" for val in array3):
        array3 = ["", "", "", "", ""]
    if not any(val != "" for val in array2):
        array2 = ["", "", "", "", ""]

    index = ""
    for i in range(len(array1) + 2):
        if i == 0:
            index = "60d Low"
        if i == 1:
            index = "30d Low"
        if i == 2:
            index = "Curr. Vol"
        if i == 3:
            index = "30d High"
        if i == 4:
            index = "60d High"
        if i == 5:
            index = "10d Rolling"
        if i == 6:
            index = "30d Rolling"
        if i <= 4:
            table.insert("", "end", text=index, values=(round(array1[i], 3), round(array2[i], 3), round((array3[i]), 3)))
        else:
            table.insert("", "end", text=index,
                         values=(round(roll1[i - 5], 3), round(roll2[i - 5], 3), round((roll3[i - 5]), 3)))

    table.pack(padx=10, pady=10)

    plt.show()
    root.mainloop()

charts()


Sub IterateFilteredTable()
    Dim ws As Worksheet
    Dim tbl As ListObject
    Dim rng As Range
    Dim rowCount As Long
    Dim currentRow As Long
    Dim previousRow As Long
    
    ' Set the worksheet and table references
    Set ws = ThisWorkbook.Worksheets("Sheet1") ' Update with your worksheet name
    Set tbl = ws.ListObjects("Table1") ' Update with your table name
    
    ' Filter the table (assuming you have applied filters)
    tbl.Range.AutoFilter
    
    ' Get the visible range of the table
    Set rng = tbl.Range.SpecialCells(xlCellTypeVisible)
    
    ' Get the row count
    rowCount = rng.Rows.Count
    
    ' Loop through the visible rows
    For currentRow = 2 To rowCount ' Assuming the table has headers and starts from row 2
        ' Save the current row number
        previousRow = currentRow - 1
        
        ' Perform your desired operations with the row numbers
        ' For example, display them in the immediate window
        Debug.Print "Current Row: " & currentRow & ", Previous Row: " & previousRow
        
        ' Continue with other processing...
    Next currentRow
    
    ' Clear the filter
    tbl.Range.AutoFilter Field:=1 ' Update the field number based on your filter criteria
    
    ' Clean up objects
    Set rng = Nothing
    Set tbl = Nothing
    Set ws = Nothing
End Sub
