Sub CallPythonScript()
    Dim scriptPath As String
    Dim pythonPath As String
    Dim cmd As String
    
    ' Set the path to the Python script
    scriptPath = "C:\path\to\your\python_script.py"
    
    ' Set the path to the Python interpreter
    pythonPath = "C:\path\to\python.exe"
    
    ' Build the command to execute the Python script
    cmd = pythonPath & " " & scriptPath
    
    ' Call the Python script using the Shell function
    Shell cmd, vbNormalFocus
End Sub


Sub SaveAndCloseExcel_CallPython()
    ' Save the file
    ThisWorkbook.Save
    
    ' Close Excel
    Application.Quit
    
    ' Call the Python script
    Dim scriptPath As String
    Dim pythonPath As String
    Dim cmd As String
    
    ' Set the path to the Python script
    scriptPath = "C:\path\to\your\python_script.py"
    
    ' Set the path to the Python interpreter
    pythonPath = "C:\path\to\python.exe"
    
    ' Build the command to execute the Python script
    cmd = pythonPath & " " & scriptPath
    
    ' Call the Python script using the Shell function
    Shell cmd, vbNormalFocus
End Sub

---------------
with this code, i want to make adjustments. all the conditions of the boxcharts should be the same (printing the values, using the arrays,etc.). now however, if there is more than one graph, the code should output a new figure for the graph. for example, if array1 and array2 both have values, then two figures should be made for the boxplots. as before, if an array is empty, do not make a boxplot. there are three possible conditions, only array1 has values so only 1 boxplot, array1 and 2 have values so 2 box plots, and all 3 arrays have values so 3 box plots: 

import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
import numpy as np
import pandas as pd
import matplotlib.patches as mpatches
from io import BytesIO
import xlsxwriter


file = pd.ExcelFile(r"C:\Users\tfang03\OneDrive - BMO Financial Group\Desktop\volpath\step 2 - filtering.xlsm")

df = file.parse('Func_hide', header = None , skiprows=1, usecols="M:T", nrows = 3)

array1 = df.iloc[0,3:].tolist()
array2 = df.iloc[1,3:].tolist()
array3 = df.iloc[2,3:].tolist()
combinedArr = array1 + array2 + array3


chart1 = str(df.iloc[0,1]) + " " +str(df.iloc[0,2])
chart2 = str(df.iloc[1,1]) + " " +str(df.iloc[1,2])
chart3 = str(df.iloc[2,1]) + " " +str(df.iloc[2,2])

# Custom values for the boxplots
# array1 = [0.5, 2.1, 3, 4.2, 5]
# array2 = [1.7,4,5,5.9,7]
# array3 = []
# combinedArr = array1 + array2 + array3
# chart1, chart2, chart3 = "chart", "chart", "chart"

# Creating the figure and axis
fig, ax = plt.subplots()
fig.set_size_inches(10,8)

# Creating the boxplots
data = []

if array1 and not any(val != "" for val in array2) and not any(val != "" for val in array3):
    # Only array1 has values, arrays 2 and 3 are all empty
    data.append(array1)

elif array1 and array2 and not any(val != "" for val in array3):
    # Array1 and array2 have values, array3 is all empty
    data.append(array1)
    data.append(array2)

elif array1 and array2 and array3:
    # All arrays have values
    data.append(array1)
    data.append(array2)
    data.append(array3)

if data:
    boxplot = ax.boxplot(data, vert=True, widths=0.5, patch_artist=True)

    # Customizing the boxplot colors
    colors = ['lightblue'] * len(data)
    for patch, color in zip(boxplot['boxes'], colors):
        patch.set_facecolor(color)

    for i, box in enumerate(boxplot['boxes']):
        if i < len(data):
            # Get the vertices (coordinates) of the box
            box_coords = box.get_path().vertices

            # Calculate the x-coordinate of the middle of the box
            mid_x = (box_coords[0, 0] + box_coords[2, 0]) / 2

            # Calculate the statistics for the current box plot
            box_values = boxplot['medians'][i].get_ydata()
            box_min = boxplot['caps'][2 * i].get_ydata()[0]
            box_max = boxplot['caps'][2 * i + 1].get_ydata()[0]

            # Add value labels for the 30d Low/High
            quartile_values = np.percentile(data[i], [25,75])
            ax.text(mid_x + 0.3, quartile_values[0], f'30d Low {quartile_values[0]:.2f}', color='blue', fontsize=6, verticalalignment='center')
            ax.text(mid_x + 0.3, quartile_values[1], f'30d Low {quartile_values[1]:.2f}', color='blue', fontsize=6, verticalalignment='center')

            # Add value label for the 60d High
            ax.text(mid_x + 0.3, box_max, f'60d High {box_max:.2f}', color='green', fontsize=6, verticalalignment='center')

            # Add value label for the 60d Low
            ax.text(mid_x + 0.3, box_min, f'60d Low {box_min:.2f}', color='green', fontsize=6, verticalalignment='center')

            # Add value label for the Current Vol
            ax.text(mid_x + 0.3, box_values[0], f'Curr. Vol {box_values[0]:.2f}', color='red', fontsize=6, verticalalignment='center')
# Adding legend
green = mpatches.Patch(color= 'green', label = '60 Day')
red = mpatches.Patch(color='red', label = "Curr. Vol")
blue = mpatches.Patch(color='blue', label = "30 Day")
plt.legend(handles=[green,red,blue])

# Setting the y-axis limits and ticks
min_value = np.inf if not data else np.nanmin([np.nanmin(arr) for arr in data])
max_value = -np.inf if not data else np.nanmax([np.nanmax(arr) for arr in data])
ax.set_ylim(min_value * -1.2, max_value * 1.2 )
ax.set_yticks(np.linspace(min_value - 0.2, max_value + 0.2, num=12))

# Setting the x-axis label
ax.set_xlabel(chart1 + " / " + chart2 + " / " + chart3)

# Adding a title
ax.set_title('Volpath')

# Displaying plot
plt.show()

-----------------------
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import matplotlib.patches as mpatches

file = pd.ExcelFile(r"C:\Users\tfang03\OneDrive - BMO Financial Group\Desktop\volpath\step 2 - filtering.xlsm")
df = file.parse('Func_hide', header=None, skiprows=1, usecols="M:T", nrows=3)

array1 = df.iloc[0, 3:].tolist()
array2 = df.iloc[1, 3:].tolist()
array3 = df.iloc[2, 3:].tolist()
combinedArr = array1 + array2 + array3

chart1 = str(df.iloc[0, 1]) + " " + str(df.iloc[0, 2])
chart2 = str(df.iloc[1, 1]) + " " + str(df.iloc[1, 2])
chart3 = str(df.iloc[2, 1]) + " " + str(df.iloc[2, 2])

# Creating the figure and axis for each boxplot
figs = []
axes = []

if array1:
    fig1, ax1 = plt.subplots()
    fig1.set_size_inches(10, 8)
    figs.append(fig1)
    axes.append(ax1)

if array2:
    fig2, ax2 = plt.subplots()
    fig2.set_size_inches(10, 8)
    figs.append(fig2)
    axes.append(ax2)

if array3:
    fig3, ax3 = plt.subplots()
    fig3.set_size_inches(10, 8)
    figs.append(fig3)
    axes.append(ax3)

# Creating the boxplots for each figure
for i, ax in enumerate(axes):
    data = []
    if array1:
        data.append(array1)
    if array2:
        data.append(array2)
    if array3:
        data.append(array3)

    if data:
        boxplot = ax.boxplot(data, vert=True, widths=0.5, patch_artist=True)

        # Customizing the boxplot colors
        colors = ['lightblue'] * len(data)
        for patch, color in zip(boxplot['boxes'], colors):
            patch.set_facecolor(color)

        for j, box in enumerate(boxplot['boxes']):
            if j < len(data):
                # Get the vertices (coordinates) of the box
                box_coords = box.get_path().vertices

                # Calculate the x-coordinate of the middle of the box
                mid_x = (box_coords[0, 0] + box_coords[2, 0]) / 2

                # Calculate the statistics for the current box plot
                box_values = boxplot['medians'][j].get_ydata()
                box_min = boxplot['caps'][2 * j].get_ydata()[0]
                box_max = boxplot['caps'][2 * j + 1].get_ydata()[0]

                # Add value labels for the 30d Low/High
                quartile_values = np.percentile(data[j], [25, 75])
                ax.text(mid_x + 0.3, quartile_values[0], f'30d Low {quartile_values[0]:.2f}', color='blue',
                        fontsize=6, verticalalignment='center')
                ax.text(mid_x + 0.3, quartile_values[1], f'30d High {quartile_values[1]:.2f}', color='blue',
                        fontsize=6, verticalalignment='center')

                # Add value label for the 60d High
                ax.text(mid_x + 0.3, box_max, f'60d High {box_max:.2f}', color='green', fontsize=6,
                        verticalalignment='center')

                # Add value label for the 60d Low
                ax.text(mid_x + 0.3, box_min, f'60d Low {box_min:.2f}', color='green', fontsize=6,
                        verticalalignment='center')

                # Add value label for the Current Vol
                ax.text(mid_x + 0.3, box_values[0], f'Current Vol {box_values[0]:.2f}', color='red', fontsize=6,
                        verticalalignment='center')

        # Adding legend
        green = mpatches.Patch(color='green', label='60 Day')
        red = mpatches.Patch(color='red', label="Current Vol")
        blue = mpatches.Patch(color='blue', label="30 Day")
        ax.legend(handles=[green, red, blue])

        # Setting the y-axis limits and ticks
        min_value = np.inf if not data else np.nanmin([np.nanmin(arr) for arr in data])
        max_value = -np.inf if not data else np.nanmax([np.nanmax(arr) for arr in data])
        ax.set_ylim(min_value * 1.2, max_value * 1.2)
        ax.set_yticks(np.linspace(min_value - 0.2, max_value + 0.2, num=12))

        # Setting the x-axis label
        ax.set_xlabel(chart1 + " / " + chart2 + " / " + chart3)

        # Adding a title
        ax.set_title('Volpath')

# Displaying plots
for fig in figs:
    plt.figure(fig.number)
    plt.show()
